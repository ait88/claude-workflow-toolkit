#!/usr/bin/env bash
# Skill: /worker
# Description: Unified workflow entry point - status, single cycle, or autonomous loop
# Usage: /worker [--status] [--once] [--help] [--project <path>] [--max-issues <n>]

set -euo pipefail

# ============================================================================
# WORKSPACE/PROJECT MODE DETECTION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_PROJECT=""
TARGET_REPO_OWNER=""
TARGET_REPO_NAME=""
MODE=""
REMAINING_ARGS=()

_parse_project_flag() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                if [[ -n "${2:-}" ]]; then
                    TARGET_PROJECT="$2"
                    shift 2
                else
                    echo "Error: --project requires a path argument"
                    exit 1
                fi
                ;;
            --repo|-r)
                if [[ -n "${2:-}" ]]; then
                    TARGET_REPO_OWNER="${2%%/*}"
                    TARGET_REPO_NAME="${2##*/}"
                    shift 2
                else
                    echo "Error: --repo requires owner/name argument"
                    exit 1
                fi
                ;;
            *)
                REMAINING_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

_load_workspace_config() {
    local config_file="${SCRIPT_DIR}/../workspace-config"
    if [[ -f "$config_file" ]]; then
        # shellcheck source=/dev/null
        source "$config_file"
        TARGET_PROJECT="${TARGET_PROJECT_PATH:-}"
        TARGET_REPO_OWNER="${TARGET_REPO_OWNER:-}"
        TARGET_REPO_NAME="${TARGET_REPO_NAME:-}"
        return 0
    fi
    return 1
}

_detect_mode() {
    if [[ -n "$TARGET_PROJECT" ]] || [[ -n "$TARGET_REPO_OWNER" ]]; then
        MODE="explicit"
        return
    fi
    if _load_workspace_config; then
        MODE="workspace"
        return
    fi
    if git rev-parse --git-dir > /dev/null 2>&1; then
        TARGET_PROJECT="$(pwd)"
        MODE="in-project"
        return
    fi
    echo "Error: Not in a git repository and no workspace config found."
    echo ""
    echo "Options:"
    echo "  1. Run from within the target project directory"
    echo "  2. Use --project <path> flag"
    echo "  3. Create .claude/workspace-config with TARGET_PROJECT_PATH"
    exit 1
}

_get_repo_info() {
    if [[ -n "$TARGET_REPO_OWNER" ]] && [[ -n "$TARGET_REPO_NAME" ]]; then
        OWNER="$TARGET_REPO_OWNER"
        REPO="$TARGET_REPO_NAME"
    else
        local repo_info
        if [[ -n "$TARGET_PROJECT" ]] && [[ "$MODE" != "in-project" ]]; then
            repo_info=$(cd "$TARGET_PROJECT" && gh repo view --json owner,name)
        else
            repo_info=$(gh repo view --json owner,name)
        fi
        OWNER=$(echo "$repo_info" | jq -r '.owner.login')
        REPO=$(echo "$repo_info" | jq -r '.name')
    fi
}

_git() {
    if [[ "$MODE" == "in-project" ]]; then
        git "$@"
    else
        git -C "$TARGET_PROJECT" "$@"
    fi
}

# ============================================================================
# END MODE DETECTION
# ============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ============================================================================
# WORKER CONFIGURATION
# ============================================================================

MAX_RETRIES={{WORKER_MAX_RETRIES}}
MAX_ISSUES={{WORKER_MAX_ISSUES}}
POLL_INTERVAL={{WORKER_POLL_INTERVAL}}
DRY_RUN=false

# Parse worker-specific flags
RESET_STATE=false
SHOW_STATUS=false
SHOW_HELP=false

_parse_worker_flags() {
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --max-issues)
                MAX_ISSUES="${2:-10}"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --once)
                MAX_ISSUES=1
                shift
                ;;
            --reset)
                RESET_STATE=true
                shift
                ;;
            --status|-s)
                SHOW_STATUS=true
                shift
                ;;
            --help|-h)
                SHOW_HELP=true
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    REMAINING_ARGS=("${args[@]+"${args[@]}"}")
}

# Reset worker state (clears current issue, decision queue, lock file)
_reset_worker_state() {
    echo "Resetting worker state..."
    rm -f "$LOCK_FILE" "$STATE_FILE" "$BRANCH_FILE" "$RETRY_FILE"
    rm -f "$DECISION_DIR"/*.json 2>/dev/null || true
    echo -e "${GREEN}Worker state cleared${NC}"
    echo ""
    echo "Cleared:"
    echo "  - Lock file"
    echo "  - Current issue tracking"
    echo "  - Decision queue"
    echo ""
    echo "Note: history.log preserved"
}

# ============================================================================
# WORKER STATE MANAGEMENT
# ============================================================================

WORKER_DIR="${SCRIPT_DIR}/../worker"
LOCK_FILE="${WORKER_DIR}/worker.lock"
STATE_FILE="${WORKER_DIR}/current-issue"
BRANCH_FILE="${WORKER_DIR}/current-branch"
RETRY_FILE="${WORKER_DIR}/retry-count"
HISTORY_FILE="${WORKER_DIR}/history.log"
DECISION_DIR="${WORKER_DIR}/decision-queue"

_init_worker_state() {
    mkdir -p "$WORKER_DIR" "$DECISION_DIR"

    # Acquire lock (prevent multiple workers on same repo)
    if [[ -f "$LOCK_FILE" ]]; then
        local pid
        pid=$(cat "$LOCK_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${RED}Error: Another worker is running (PID: $pid)${NC}"
            echo "Lock file: $LOCK_FILE"
            echo ""
            echo "If the previous worker crashed, remove the lock file:"
            echo "  rm $LOCK_FILE"
            exit 1
        fi
        # Stale lock, remove it
        echo -e "${YELLOW}Removing stale lock file from PID $pid${NC}"
        rm "$LOCK_FILE"
    fi
    echo $$ > "$LOCK_FILE"
    trap _cleanup_worker EXIT
}

_cleanup_worker() {
    rm -f "$LOCK_FILE"
}

_get_current_issue() {
    [[ -f "$STATE_FILE" ]] && cat "$STATE_FILE" || echo ""
}

_get_current_branch() {
    [[ -f "$BRANCH_FILE" ]] && cat "$BRANCH_FILE" || echo ""
}

_set_current_issue() {
    local issue="$1"
    local branch="${2:-}"
    echo "$issue" > "$STATE_FILE"
    [[ -n "$branch" ]] && echo "$branch" > "$BRANCH_FILE"
    echo "0" > "$RETRY_FILE"
}

_clear_current_issue() {
    rm -f "$STATE_FILE" "$BRANCH_FILE" "$RETRY_FILE"
}

_get_retry_count() {
    [[ -f "$RETRY_FILE" ]] && cat "$RETRY_FILE" || echo "0"
}

_increment_retry() {
    local count
    count=$(_get_retry_count)
    echo $((count + 1)) > "$RETRY_FILE"
}

_log_history() {
    local status="$1"
    local issue="$2"
    local message="${3:-}"
    echo "$(date -Iseconds) | $status | #$issue | $message" >> "$HISTORY_FILE"
}

# ============================================================================
# DECISION QUEUE
# ============================================================================

_queue_decision() {
    local issue="$1"
    local title="$2"
    local context="$3"
    local options="$4"

    local timestamp
    timestamp=$(date -Iseconds)
    local filename="${timestamp}-issue-${issue}.json"

    cat > "${DECISION_DIR}/${filename}" << EOF
{
    "timestamp": "$timestamp",
    "issue": $issue,
    "title": "$title",
    "context": "$context",
    "options": $options,
    "status": "pending"
}
EOF

    echo -e "${YELLOW}Decision queued:${NC} ${DECISION_DIR}/${filename}"
    _log_history "DECISION" "$issue" "$title"
}

_check_pending_decisions() {
    local count
    count=$(find "$DECISION_DIR" -name "*.json" -type f 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$count" -gt 0 ]]; then
        echo -e "${YELLOW}Note: $count pending decision(s) in queue${NC}"
        echo "  Review: ls $DECISION_DIR"
        echo ""
    fi
}

# ============================================================================
# QUALITY GATES
# ============================================================================

_run_quality_gates() {
    local issue="$1"
    local failed=0

    echo ""
    echo "========================================"
    echo "Running Quality Gates"
    echo "========================================"
    echo ""

    # Gate 1: Tests
    echo -n "Tests: "
    if _run_tests; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi

    # Gate 2: Lint
    echo -n "Lint:  "
    if _run_lint; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi

    # Gate 3: Security check
    echo -n "Security: "
    local security_issues
    security_issues=$(_run_security_check)
    if [[ "$security_issues" -eq 0 ]]; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${YELLOW}WARN ($security_issues issue(s))${NC}"
        # Security warnings don't fail the gate, but are noted
    fi

    echo ""

    if [[ "$failed" -eq 0 ]]; then
        echo -e "${GREEN}All quality gates passed${NC}"
        return 0
    else
        echo -e "${RED}$failed quality gate(s) failed${NC}"
        return 1
    fi
}

_run_tests() {
    local test_cmd="{{TEST_COMMAND}}"
    if [[ "$test_cmd" == "echo"* ]] || [[ -z "$test_cmd" ]]; then
        # No test command configured
        return 0
    fi

    if [[ "$MODE" == "in-project" ]]; then
        eval "$test_cmd" > /dev/null 2>&1
    else
        (cd "$TARGET_PROJECT" && eval "$test_cmd") > /dev/null 2>&1
    fi
}

_run_lint() {
    local lint_cmd="{{LINT_COMMAND}}"
    if [[ "$lint_cmd" == "echo"* ]] || [[ -z "$lint_cmd" ]]; then
        # No lint command configured
        return 0
    fi

    if [[ "$MODE" == "in-project" ]]; then
        eval "$lint_cmd" > /dev/null 2>&1
    else
        (cd "$TARGET_PROJECT" && eval "$lint_cmd") > /dev/null 2>&1
    fi
}

_run_security_check() {
    local issues=0

    # Check for potential secrets in staged files
    if _git diff --cached --name-only 2>/dev/null | xargs grep -l -E '(password|secret|api_key|apikey|token)\s*=' 2>/dev/null | head -1 | grep -q .; then
        ((issues++))
    fi

    # Check for debug statements
    if _git diff --cached 2>/dev/null | grep -E '^\+.*(console\.log|var_dump|print_r|debugger|binding\.pry)' | head -1 | grep -q .; then
        ((issues++))
    fi

    echo "$issues"
}

# ============================================================================
# ISSUE DISCOVERY
# ============================================================================

_find_next_issue() {
    # Query for agent-ready issues, prioritized by phase label
    local issues
    issues=$(gh issue list --repo "$OWNER/$REPO" \
        --label "agent-ready" \
        --state open \
        --json number,title,labels \
        --jq 'sort_by(.labels | map(select(.name | startswith("{{PHASE_PREFIX}}"))) | .[0].name // "{{PHASE_PREFIX}}99") | .[0]' 2>/dev/null)

    if [[ -z "$issues" || "$issues" == "null" ]]; then
        return 1
    fi

    echo "$issues"
}

_has_pending_reviews() {
    # Check for PRs authored by us with unaddressed review comments
    local review_count
    review_count=$(gh pr list --repo "$OWNER/$REPO" --state open \
        --json number,reviews \
        --jq '[.[] | select(.reviews | length > 0) | select(.reviews | map(select(.state == "CHANGES_REQUESTED")) | length > 0)] | length' 2>/dev/null || echo "0")

    [[ "$review_count" -gt 0 ]]
}

# ============================================================================
# GIT HELPERS
# ============================================================================

git_with_fallback() {
    local cmd="$1"
    shift
    if ! _git "$cmd" "$@" 2>/dev/null; then
        echo "SSH failed, trying HTTPS via gh auth..."
        gh auth setup-git 2>/dev/null || true
        _git "$cmd" "$@"
    fi
}

_has_uncommitted_changes() {
    ! _git diff --quiet 2>/dev/null || ! _git diff --cached --quiet 2>/dev/null
}

_has_commits_ahead() {
    local count
    count=$(_git rev-list --count "origin/{{DEFAULT_BRANCH}}..HEAD" 2>/dev/null || echo "0")
    [[ "$count" -gt 0 ]]
}

# ============================================================================
# HELP AND STATUS
# ============================================================================

_show_help() {
    cat <<EOF
Usage: /worker [OPTIONS]

Unified workflow entry point for development.

MODES:
  /worker --status      Show workflow status (skills, reviews, issues)
  /worker --once        Run one complete cycle (claim → implement → submit)
  /worker               Continuous autonomous loop
  /worker --help        Show this help message

OPTIONS:
  --status, -s          Show workflow status without taking action
  --once                Process exactly one issue then stop
  --max-issues <n>      Maximum issues to process (default: {{WORKER_MAX_ISSUES}})
  --dry-run             Show what would happen without making changes
  --reset               Clear worker state (lock, current issue, queue)
  --project, -p <path>  Target project path (overrides workspace config)
  --repo, -r <o/n>      GitHub repo as owner/name (overrides auto-detection)
  --help, -h            Show this help message

WORKFLOW:
  1. /worker --status   Check what needs attention
  2. /worker --once     Start one work cycle
  3. Implement solution
  4. /worker --once     Continue (runs quality gates, submits PR)
  5. Repeat

EXAMPLES:
  /worker --status                    # See current state
  /worker --once                      # Claim and start one issue
  /worker --once --dry-run            # Preview without changes
  /worker --max-issues 3              # Process up to 3 issues
  /worker --reset                     # Clear stale state

STATE FILES:
  Worker state is stored in: ${SCRIPT_DIR}/../worker/
  - current-issue: Currently claimed issue
  - history.log: Completed issue history
  - decision-queue/: Issues needing human input

EOF
}

_check_skill_staleness() {
    # Returns: 0=up-to-date, 1=outdated, 2=cannot-check
    # Sets: SKILLS_OUTDATED, SKILLS_MISSING
    SKILLS_OUTDATED=0
    SKILLS_MISSING=0

    # Find toolkit source
    local toolkit_source="${TOOLKIT_SOURCE:-}"
    # Expand tilde if present (tilde doesn't expand when read from config file)
    toolkit_source="${toolkit_source/#\~/$HOME}"

    if [[ -z "$toolkit_source" ]]; then
        if [[ -d "$HOME/claude-workflow-toolkit" ]]; then
            toolkit_source="$HOME/claude-workflow-toolkit"
        elif [[ -d "${SCRIPT_DIR}/../../templates" ]]; then
            toolkit_source="$(realpath "${SCRIPT_DIR}/../..")"
        fi
    fi

    if [[ -z "$toolkit_source" ]] || [[ ! -d "$toolkit_source/templates/skills" ]]; then
        return 2  # Cannot check
    fi

    local skills_dir="${SCRIPT_DIR}"
    for template in "$toolkit_source/templates/skills/"*.sh.template; do
        [[ -f "$template" ]] || continue
        local skill_name
        skill_name=$(basename "$template" .sh.template)
        local installed_file="$skills_dir/$skill_name"

        if [[ ! -f "$installed_file" ]]; then
            ((++SKILLS_MISSING))
        elif [[ "$template" -nt "$installed_file" ]]; then
            ((++SKILLS_OUTDATED))
        fi
    done

    if [[ $SKILLS_OUTDATED -eq 0 ]] && [[ $SKILLS_MISSING -eq 0 ]]; then
        return 0  # Up to date
    fi
    return 1  # Outdated
}

_get_branch_context() {
    # Returns context about current branch state
    # Sets: BRANCH_NAME, BRANCH_ISSUE, BRANCH_CONTEXT
    BRANCH_NAME=$(_git branch --show-current 2>/dev/null || echo "")
    BRANCH_ISSUE=""
    BRANCH_CONTEXT="unknown"

    if [[ -z "$BRANCH_NAME" ]]; then
        BRANCH_CONTEXT="detached"
        return
    fi

    if [[ "$BRANCH_NAME" == "{{DEFAULT_BRANCH}}" ]] || [[ "$BRANCH_NAME" == "main" ]] || [[ "$BRANCH_NAME" == "master" ]]; then
        BRANCH_CONTEXT="default"
        return
    fi

    # Extract issue number from branch name
    BRANCH_ISSUE=$(echo "$BRANCH_NAME" | grep -oE '^[0-9]+' || echo "")

    if [[ -z "$BRANCH_ISSUE" ]]; then
        BRANCH_CONTEXT="feature"  # Feature branch without issue number
        return
    fi

    # Check issue state
    local issue_state
    issue_state=$(gh issue view "$BRANCH_ISSUE" --repo "$OWNER/$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")

    case "$issue_state" in
        OPEN)
            BRANCH_CONTEXT="active"
            ;;
        CLOSED)
            BRANCH_CONTEXT="closed"
            ;;
        *)
            BRANCH_CONTEXT="unknown"
            ;;
    esac
}

_show_status() {
    echo ""
    echo "========================================"
    echo -e "${BLUE}Workflow Status${NC}"
    echo "========================================"
    echo ""
    echo -e "Repository: ${BLUE}$OWNER/$REPO${NC}"

    # Branch context
    _get_branch_context
    echo -e "Branch:     ${BLUE}$BRANCH_NAME${NC}"
    echo ""

    # Skills staleness
    echo "----------------------------------------"
    echo "Pre-flight Checks"
    echo "----------------------------------------"
    echo ""

    _check_skill_staleness
    local staleness_result=$?
    case $staleness_result in
        0)
            echo -e "${GREEN}✓ Skills:${NC} Up to date"
            ;;
        1)
            echo -e "${YELLOW}! Skills:${NC} $SKILLS_OUTDATED outdated, $SKILLS_MISSING missing"
            echo -e "  Run: ${BLUE}/sync-skills${NC}"
            ;;
        2)
            echo -e "${YELLOW}? Skills:${NC} Could not locate toolkit for validation"
            ;;
    esac

    # Pending reviews
    local pending_reviews
    pending_reviews=$(gh pr list --repo "$OWNER/$REPO" --state open --json number,reviews \
        --jq '[.[] | select(.reviews | length > 0) | select(.reviews | map(select(.state == "CHANGES_REQUESTED")) | length > 0)] | length' 2>/dev/null || echo "0")

    if [[ "$pending_reviews" -gt 0 ]]; then
        echo -e "${YELLOW}! Reviews:${NC} $pending_reviews PR(s) need attention"
        echo -e "  Run: ${BLUE}/check-reviews${NC}"
    else
        echo -e "${GREEN}✓ Reviews:${NC} None pending"
    fi

    # Available issues
    local agent_ready
    agent_ready=$(gh issue list --repo "$OWNER/$REPO" --label "agent-ready" --state open --json number --jq 'length' 2>/dev/null || echo "0")
    echo -e "${BLUE}ℹ Issues:${NC}  $agent_ready ready for work"

    # Current worker state
    local current_issue
    current_issue=$(_get_current_issue 2>/dev/null || echo "")
    if [[ -n "$current_issue" ]]; then
        echo -e "${BLUE}ℹ Worker:${NC}  Issue #$current_issue in progress"
    fi

    # Pending decisions
    local decision_count
    decision_count=$(find "$DECISION_DIR" -name "*.json" -type f 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$decision_count" -gt 0 ]]; then
        echo -e "${YELLOW}! Queue:${NC}   $decision_count decision(s) pending"
        echo -e "  Review: ${BLUE}ls $DECISION_DIR${NC}"
    fi

    echo ""
    echo "----------------------------------------"
    echo "Next Steps"
    echo "----------------------------------------"
    echo ""

    # Context-aware next steps (addresses #34)
    case "$BRANCH_CONTEXT" in
        closed)
            echo -e "${YELLOW}You're on a branch for closed issue #$BRANCH_ISSUE${NC}"
            echo ""
            echo "Suggested actions:"
            echo -e "  ${BLUE}git checkout {{DEFAULT_BRANCH}} && git pull${NC}"
            echo -e "  ${BLUE}/worker --status${NC}"
            ;;
        active)
            echo -e "Working on issue #$BRANCH_ISSUE"
            echo ""
            if [[ -n "$current_issue" ]] && [[ "$current_issue" == "$BRANCH_ISSUE" ]]; then
                if _has_commits_ahead 2>/dev/null; then
                    echo "Ready for quality gates and PR submission:"
                    echo -e "  ${BLUE}/worker --once${NC}    Run quality gates and submit PR"
                elif _has_uncommitted_changes 2>/dev/null; then
                    echo "Uncommitted changes detected:"
                    echo -e "  ${BLUE}git add . && git commit${NC}"
                    echo -e "  ${BLUE}/worker --once${NC}"
                else
                    echo "Implement the solution, then:"
                    echo -e "  ${BLUE}/worker --once${NC}    Continue workflow"
                fi
            else
                echo "Continue working or submit:"
                echo -e "  ${BLUE}/worker --once${NC}    Run quality gates and submit PR"
            fi
            ;;
        default)
            if [[ "$pending_reviews" -gt 0 ]]; then
                echo "Address reviews first:"
                echo -e "  ${BLUE}/check-reviews${NC}       See review details"
                echo -e "  ${BLUE}/address-review <n>${NC}  Checkout PR and see feedback"
            elif [[ "$agent_ready" -gt 0 ]]; then
                echo "Ready to start work:"
                echo -e "  ${BLUE}/worker --once${NC}       Claim next issue and start"
                echo -e "  ${BLUE}/claim-issue <n>${NC}     Claim specific issue"
                echo ""
                echo "Find work:"
                echo -e "  ${BLUE}gh issue list --repo $OWNER/$REPO --label agent-ready${NC}"
            else
                echo "No issues ready for work."
                echo ""
                echo "Check for new issues or create one:"
                echo -e "  ${BLUE}gh issue list --repo $OWNER/$REPO${NC}"
            fi
            ;;
        *)
            echo "Available commands:"
            echo -e "  ${BLUE}/worker --once${NC}       Start or continue one work cycle"
            echo -e "  ${BLUE}/worker${NC}              Run autonomous loop"
            echo -e "  ${BLUE}/check-reviews${NC}       Check for PR feedback"
            echo -e "  ${BLUE}/claim-issue <n>${NC}     Claim specific issue"
            ;;
    esac

    echo ""
}

# ============================================================================
# MAIN WORKER LOOP
# ============================================================================

_worker_loop() {
    local issues_completed=0

    echo ""
    echo "========================================"
    echo -e "${BLUE}Worker Agent Started${NC}"
    echo "========================================"
    echo "Repository:  $OWNER/$REPO"
    echo "Max issues:  $MAX_ISSUES"
    echo "Max retries: $MAX_RETRIES"
    echo "Dry run:     $DRY_RUN"
    echo ""

    _check_pending_decisions

    while [[ $issues_completed -lt $MAX_ISSUES ]]; do
        echo ""
        echo "----------------------------------------"
        echo "Cycle $((issues_completed + 1)) of $MAX_ISSUES"
        echo "----------------------------------------"

        # Step 1: Check for review feedback first (priority workflow)
        echo ""
        echo -e "${BLUE}Step 1:${NC} Checking for pending reviews..."
        if _has_pending_reviews; then
            echo -e "${YELLOW}Found PRs with requested changes${NC}"
            echo ""
            echo "Run /check-reviews to see details, then /address-review <pr>"
            echo "Worker pausing until reviews are addressed."
            return 0
        fi
        echo "No pending reviews requiring changes"

        # Step 2: Check for in-progress work
        local current_issue
        current_issue=$(_get_current_issue)

        if [[ -n "$current_issue" ]]; then
            echo ""
            echo -e "${BLUE}Step 2:${NC} Resuming in-progress issue #$current_issue..."

            # Check if we have commits ready for quality gates
            if _has_commits_ahead; then
                echo "Found commits ready for quality gates"
            elif _has_uncommitted_changes; then
                echo ""
                echo -e "${YELLOW}Uncommitted changes detected${NC}"
                echo "Stage and commit your changes, then run /worker again"
                return 0
            else
                echo ""
                echo "Issue #$current_issue is claimed but no implementation yet."
                echo ""
                echo "Implement the solution, then run /worker again."
                echo "  View issue: gh issue view $current_issue --repo $OWNER/$REPO --web"
                return 0
            fi
        else
            # Step 3: Find and claim next issue
            echo ""
            echo -e "${BLUE}Step 3:${NC} Finding next issue..."
            local next_issue
            next_issue=$(_find_next_issue) || {
                echo "No agent-ready issues found"
                if [[ $issues_completed -eq 0 ]]; then
                    echo ""
                    echo "Waiting ${POLL_INTERVAL}s before checking again..."
                    echo "(Press Ctrl+C to stop)"
                    sleep "$POLL_INTERVAL"
                    continue
                else
                    echo ""
                    echo -e "${GREEN}Worker complete${NC} - $issues_completed issue(s) processed"
                    return 0
                fi
            }

            local issue_num
            issue_num=$(echo "$next_issue" | jq -r '.number')
            local issue_title
            issue_title=$(echo "$next_issue" | jq -r '.title')

            echo "Found: #$issue_num - $issue_title"

            if $DRY_RUN; then
                echo -e "${YELLOW}[DRY RUN]${NC} Would claim issue #$issue_num"
                ((++issues_completed))
                continue
            fi

            # Claim the issue atomically using existing skill
            echo ""
            echo -e "${BLUE}Step 4:${NC} Claiming issue..."
            local claim_output
            if ! claim_output=$("${SCRIPT_DIR}/claim-issue" "$issue_num" 2>&1); then
                echo -e "${RED}Failed to claim issue #$issue_num${NC}"
                echo "$claim_output"
                # Extract last line as error summary
                local error_summary
                error_summary=$(echo "$claim_output" | grep -i "error\|failed\|not found" | tail -1 | cut -c1-100)
                _log_history "CLAIM_FAILED" "$issue_num" "${error_summary:-Claim failed}"
                continue
            fi
            echo "$claim_output"

            local branch
            branch=$(_git branch --show-current 2>/dev/null || echo "")
            _set_current_issue "$issue_num" "$branch"
            current_issue="$issue_num"

            echo ""
            echo "Issue #$current_issue claimed. Implement the solution, then run /worker again."
            return 0
        fi

        # Step 5: Quality gates (only reached if we have commits)
        echo ""
        echo -e "${BLUE}Step 5:${NC} Running quality gates..."

        local retry_count
        retry_count=$(_get_retry_count)

        if ! _run_quality_gates "$current_issue"; then
            _increment_retry
            retry_count=$(_get_retry_count)

            if [[ "$retry_count" -ge "$MAX_RETRIES" ]]; then
                echo ""
                echo -e "${RED}Quality gates failed after $MAX_RETRIES attempts${NC}"
                _queue_decision "$current_issue" \
                    "Quality gates failing" \
                    "Tests or lint failing after $MAX_RETRIES fix attempts" \
                    '["Fix manually", "Skip quality gates", "Abandon issue"]'
                _log_history "BLOCKED" "$current_issue" "Quality gates failed after $MAX_RETRIES attempts"
                _clear_current_issue
                ((++issues_completed))
                continue
            fi

            echo ""
            echo "Attempt $retry_count of $MAX_RETRIES"
            echo "Fix the issues above and run /worker again"
            return 1
        fi

        # Step 6: Submit PR
        echo ""
        echo -e "${BLUE}Step 6:${NC} Submitting PR..."

        if $DRY_RUN; then
            echo -e "${YELLOW}[DRY RUN]${NC} Would submit PR for issue #$current_issue"
        else
            local submit_output
            if ! submit_output=$("${SCRIPT_DIR}/submit-pr" 2>&1); then
                echo -e "${RED}Failed to submit PR${NC}"
                echo "$submit_output"
                _log_history "FAILED" "$current_issue" "PR submission failed"
                # Escape quotes in output for JSON and truncate if too long
                local error_context
                error_context=$(echo "$submit_output" | tail -10 | sed 's/"/\\"/g' | tr '\n' ' ' | cut -c1-500)
                _queue_decision "$current_issue" \
                    "PR submission failed" \
                    "Error: ${error_context}" \
                    '["Retry manually", "Abandon issue"]'
                _clear_current_issue
                ((++issues_completed))
                continue
            fi
        fi

        echo ""
        echo -e "${GREEN}Issue #$current_issue completed successfully${NC}"
        _log_history "COMPLETED" "$current_issue" "PR submitted"
        _clear_current_issue
        ((++issues_completed))
    done

    echo ""
    echo "========================================"
    echo -e "${GREEN}Worker Complete${NC}"
    echo "========================================"
    echo "Issues processed: $issues_completed"
    echo ""
    echo "Review history: $HISTORY_FILE"
    return 0
}

# ============================================================================
# MAIN
# ============================================================================

# Parse flags in correct order
_parse_project_flag "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"
REMAINING_ARGS=()
_parse_worker_flags "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"

# Handle --help flag early (before mode detection)
if $SHOW_HELP; then
    _show_help
    exit 0
fi

# Initialize
_detect_mode
_get_repo_info

# Set up worker paths (needed for status and reset)
WORKER_DIR="${SCRIPT_DIR}/../worker"
LOCK_FILE="${WORKER_DIR}/worker.lock"
STATE_FILE="${WORKER_DIR}/current-issue"
BRANCH_FILE="${WORKER_DIR}/current-branch"
RETRY_FILE="${WORKER_DIR}/retry-count"
DECISION_DIR="${WORKER_DIR}/decision-queue"
mkdir -p "$WORKER_DIR" "$DECISION_DIR"

# Handle --reset flag
if $RESET_STATE; then
    _reset_worker_state
    exit 0
fi

# Handle --status flag
if $SHOW_STATUS; then
    _show_status
    exit 0
fi

_init_worker_state

# Run the loop
_worker_loop
exit 0
