#!/usr/bin/env bash
# Skill: /worker
# Description: Autonomous development loop - claim issues, implement, test, submit PRs
# Usage: /worker [--project <path>] [--max-issues <n>] [--once] [--dry-run]

set -euo pipefail

# ============================================================================
# WORKSPACE/PROJECT MODE DETECTION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_PROJECT=""
TARGET_REPO_OWNER=""
TARGET_REPO_NAME=""
MODE=""
REMAINING_ARGS=()

_parse_project_flag() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                if [[ -n "${2:-}" ]]; then
                    TARGET_PROJECT="$2"
                    shift 2
                else
                    echo "Error: --project requires a path argument"
                    exit 1
                fi
                ;;
            --repo|-r)
                if [[ -n "${2:-}" ]]; then
                    TARGET_REPO_OWNER="${2%%/*}"
                    TARGET_REPO_NAME="${2##*/}"
                    shift 2
                else
                    echo "Error: --repo requires owner/name argument"
                    exit 1
                fi
                ;;
            *)
                REMAINING_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

_load_workspace_config() {
    local config_file="${SCRIPT_DIR}/../workspace-config"
    if [[ -f "$config_file" ]]; then
        # shellcheck source=/dev/null
        source "$config_file"
        TARGET_PROJECT="${TARGET_PROJECT_PATH:-}"
        TARGET_REPO_OWNER="${TARGET_REPO_OWNER:-}"
        TARGET_REPO_NAME="${TARGET_REPO_NAME:-}"
        return 0
    fi
    return 1
}

_detect_mode() {
    if [[ -n "$TARGET_PROJECT" ]] || [[ -n "$TARGET_REPO_OWNER" ]]; then
        MODE="explicit"
        return
    fi
    if _load_workspace_config; then
        MODE="workspace"
        return
    fi
    if git rev-parse --git-dir > /dev/null 2>&1; then
        TARGET_PROJECT="$(pwd)"
        MODE="in-project"
        return
    fi
    echo "Error: Not in a git repository and no workspace config found."
    echo ""
    echo "Options:"
    echo "  1. Run from within the target project directory"
    echo "  2. Use --project <path> flag"
    echo "  3. Create .claude/workspace-config with TARGET_PROJECT_PATH"
    exit 1
}

_get_repo_info() {
    if [[ -n "$TARGET_REPO_OWNER" ]] && [[ -n "$TARGET_REPO_NAME" ]]; then
        OWNER="$TARGET_REPO_OWNER"
        REPO="$TARGET_REPO_NAME"
    else
        local repo_info
        if [[ -n "$TARGET_PROJECT" ]] && [[ "$MODE" != "in-project" ]]; then
            repo_info=$(cd "$TARGET_PROJECT" && gh repo view --json owner,name)
        else
            repo_info=$(gh repo view --json owner,name)
        fi
        OWNER=$(echo "$repo_info" | jq -r '.owner.login')
        REPO=$(echo "$repo_info" | jq -r '.name')
    fi
}

_git() {
    if [[ "$MODE" == "in-project" ]]; then
        git "$@"
    else
        git -C "$TARGET_PROJECT" "$@"
    fi
}

# ============================================================================
# END MODE DETECTION
# ============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# ============================================================================
# WORKER CONFIGURATION
# ============================================================================

MAX_RETRIES={{WORKER_MAX_RETRIES}}
MAX_ISSUES={{WORKER_MAX_ISSUES}}
POLL_INTERVAL={{WORKER_POLL_INTERVAL}}
DRY_RUN=false

# Parse worker-specific flags
RESET_STATE=false

_parse_worker_flags() {
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --max-issues)
                MAX_ISSUES="${2:-10}"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --once)
                MAX_ISSUES=1
                shift
                ;;
            --reset)
                RESET_STATE=true
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    REMAINING_ARGS=("${args[@]+"${args[@]}"}")
}

# Reset worker state (clears current issue, decision queue, lock file)
_reset_worker_state() {
    echo "Resetting worker state..."
    rm -f "$LOCK_FILE" "$STATE_FILE" "$BRANCH_FILE" "$RETRY_FILE"
    rm -f "$DECISION_DIR"/*.json 2>/dev/null || true
    echo -e "${GREEN}Worker state cleared${NC}"
    echo ""
    echo "Cleared:"
    echo "  - Lock file"
    echo "  - Current issue tracking"
    echo "  - Decision queue"
    echo ""
    echo "Note: history.log preserved"
}

# ============================================================================
# WORKER STATE MANAGEMENT
# ============================================================================

WORKER_DIR="${SCRIPT_DIR}/../worker"
LOCK_FILE="${WORKER_DIR}/worker.lock"
STATE_FILE="${WORKER_DIR}/current-issue"
BRANCH_FILE="${WORKER_DIR}/current-branch"
RETRY_FILE="${WORKER_DIR}/retry-count"
HISTORY_FILE="${WORKER_DIR}/history.log"
DECISION_DIR="${WORKER_DIR}/decision-queue"

_init_worker_state() {
    mkdir -p "$WORKER_DIR" "$DECISION_DIR"

    # Acquire lock (prevent multiple workers on same repo)
    if [[ -f "$LOCK_FILE" ]]; then
        local pid
        pid=$(cat "$LOCK_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${RED}Error: Another worker is running (PID: $pid)${NC}"
            echo "Lock file: $LOCK_FILE"
            echo ""
            echo "If the previous worker crashed, remove the lock file:"
            echo "  rm $LOCK_FILE"
            exit 1
        fi
        # Stale lock, remove it
        echo -e "${YELLOW}Removing stale lock file from PID $pid${NC}"
        rm "$LOCK_FILE"
    fi
    echo $$ > "$LOCK_FILE"
    trap _cleanup_worker EXIT
}

_cleanup_worker() {
    rm -f "$LOCK_FILE"
}

_get_current_issue() {
    [[ -f "$STATE_FILE" ]] && cat "$STATE_FILE" || echo ""
}

_get_current_branch() {
    [[ -f "$BRANCH_FILE" ]] && cat "$BRANCH_FILE" || echo ""
}

_set_current_issue() {
    local issue="$1"
    local branch="${2:-}"
    echo "$issue" > "$STATE_FILE"
    [[ -n "$branch" ]] && echo "$branch" > "$BRANCH_FILE"
    echo "0" > "$RETRY_FILE"
}

_clear_current_issue() {
    rm -f "$STATE_FILE" "$BRANCH_FILE" "$RETRY_FILE"
}

_get_retry_count() {
    [[ -f "$RETRY_FILE" ]] && cat "$RETRY_FILE" || echo "0"
}

_increment_retry() {
    local count
    count=$(_get_retry_count)
    echo $((count + 1)) > "$RETRY_FILE"
}

_log_history() {
    local status="$1"
    local issue="$2"
    local message="${3:-}"
    echo "$(date -Iseconds) | $status | #$issue | $message" >> "$HISTORY_FILE"
}

# ============================================================================
# DECISION QUEUE
# ============================================================================

_queue_decision() {
    local issue="$1"
    local title="$2"
    local context="$3"
    local options="$4"

    local timestamp
    timestamp=$(date -Iseconds)
    local filename="${timestamp}-issue-${issue}.json"

    cat > "${DECISION_DIR}/${filename}" << EOF
{
    "timestamp": "$timestamp",
    "issue": $issue,
    "title": "$title",
    "context": "$context",
    "options": $options,
    "status": "pending"
}
EOF

    echo -e "${YELLOW}Decision queued:${NC} ${DECISION_DIR}/${filename}"
    _log_history "DECISION" "$issue" "$title"
}

_check_pending_decisions() {
    local count
    count=$(find "$DECISION_DIR" -name "*.json" -type f 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$count" -gt 0 ]]; then
        echo -e "${YELLOW}Note: $count pending decision(s) in queue${NC}"
        echo "  Review: ls $DECISION_DIR"
        echo ""
    fi
}

# ============================================================================
# QUALITY GATES
# ============================================================================

_run_quality_gates() {
    local issue="$1"
    local failed=0

    echo ""
    echo "========================================"
    echo "Running Quality Gates"
    echo "========================================"
    echo ""

    # Gate 1: Tests
    echo -n "Tests: "
    if _run_tests; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi

    # Gate 2: Lint
    echo -n "Lint:  "
    if _run_lint; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi

    # Gate 3: Security check
    echo -n "Security: "
    local security_issues
    security_issues=$(_run_security_check)
    if [[ "$security_issues" -eq 0 ]]; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${YELLOW}WARN ($security_issues issue(s))${NC}"
        # Security warnings don't fail the gate, but are noted
    fi

    echo ""

    if [[ "$failed" -eq 0 ]]; then
        echo -e "${GREEN}All quality gates passed${NC}"
        return 0
    else
        echo -e "${RED}$failed quality gate(s) failed${NC}"
        return 1
    fi
}

_run_tests() {
    local test_cmd="{{TEST_COMMAND}}"
    if [[ "$test_cmd" == "echo"* ]] || [[ -z "$test_cmd" ]]; then
        # No test command configured
        return 0
    fi

    if [[ "$MODE" == "in-project" ]]; then
        eval "$test_cmd" > /dev/null 2>&1
    else
        (cd "$TARGET_PROJECT" && eval "$test_cmd") > /dev/null 2>&1
    fi
}

_run_lint() {
    local lint_cmd="{{LINT_COMMAND}}"
    if [[ "$lint_cmd" == "echo"* ]] || [[ -z "$lint_cmd" ]]; then
        # No lint command configured
        return 0
    fi

    if [[ "$MODE" == "in-project" ]]; then
        eval "$lint_cmd" > /dev/null 2>&1
    else
        (cd "$TARGET_PROJECT" && eval "$lint_cmd") > /dev/null 2>&1
    fi
}

_run_security_check() {
    local issues=0

    # Check for potential secrets in staged files
    if _git diff --cached --name-only 2>/dev/null | xargs grep -l -E '(password|secret|api_key|apikey|token)\s*=' 2>/dev/null | head -1 | grep -q .; then
        ((issues++))
    fi

    # Check for debug statements
    if _git diff --cached 2>/dev/null | grep -E '^\+.*(console\.log|var_dump|print_r|debugger|binding\.pry)' | head -1 | grep -q .; then
        ((issues++))
    fi

    echo "$issues"
}

# ============================================================================
# ISSUE DISCOVERY
# ============================================================================

_find_next_issue() {
    # Query for agent-ready issues, prioritized by phase label
    local issues
    issues=$(gh issue list --repo "$OWNER/$REPO" \
        --label "agent-ready" \
        --state open \
        --json number,title,labels \
        --jq 'sort_by(.labels | map(select(.name | startswith("{{PHASE_PREFIX}}"))) | .[0].name // "{{PHASE_PREFIX}}99") | .[0]' 2>/dev/null)

    if [[ -z "$issues" || "$issues" == "null" ]]; then
        return 1
    fi

    echo "$issues"
}

_has_pending_reviews() {
    # Check for PRs authored by us with unaddressed review comments
    local review_count
    review_count=$(gh pr list --repo "$OWNER/$REPO" --state open \
        --json number,reviews \
        --jq '[.[] | select(.reviews | length > 0) | select(.reviews | map(select(.state == "CHANGES_REQUESTED")) | length > 0)] | length' 2>/dev/null || echo "0")

    [[ "$review_count" -gt 0 ]]
}

# ============================================================================
# GIT HELPERS
# ============================================================================

git_with_fallback() {
    local cmd="$1"
    shift
    if ! _git "$cmd" "$@" 2>/dev/null; then
        echo "SSH failed, trying HTTPS via gh auth..."
        gh auth setup-git 2>/dev/null || true
        _git "$cmd" "$@"
    fi
}

_has_uncommitted_changes() {
    ! _git diff --quiet 2>/dev/null || ! _git diff --cached --quiet 2>/dev/null
}

_has_commits_ahead() {
    local count
    count=$(_git rev-list --count "origin/{{DEFAULT_BRANCH}}..HEAD" 2>/dev/null || echo "0")
    [[ "$count" -gt 0 ]]
}

# ============================================================================
# MAIN WORKER LOOP
# ============================================================================

_worker_loop() {
    local issues_completed=0

    echo ""
    echo "========================================"
    echo -e "${BLUE}Worker Agent Started${NC}"
    echo "========================================"
    echo "Repository:  $OWNER/$REPO"
    echo "Max issues:  $MAX_ISSUES"
    echo "Max retries: $MAX_RETRIES"
    echo "Dry run:     $DRY_RUN"
    echo ""

    _check_pending_decisions

    while [[ $issues_completed -lt $MAX_ISSUES ]]; do
        echo ""
        echo "----------------------------------------"
        echo "Cycle $((issues_completed + 1)) of $MAX_ISSUES"
        echo "----------------------------------------"

        # Step 1: Check for review feedback first (priority workflow)
        echo ""
        echo -e "${BLUE}Step 1:${NC} Checking for pending reviews..."
        if _has_pending_reviews; then
            echo -e "${YELLOW}Found PRs with requested changes${NC}"
            echo ""
            echo "Run /check-reviews to see details, then /address-review <pr>"
            echo "Worker pausing until reviews are addressed."
            return 0
        fi
        echo "No pending reviews requiring changes"

        # Step 2: Check for in-progress work
        local current_issue
        current_issue=$(_get_current_issue)

        if [[ -n "$current_issue" ]]; then
            echo ""
            echo -e "${BLUE}Step 2:${NC} Resuming in-progress issue #$current_issue..."

            # Check if we have commits ready for quality gates
            if _has_commits_ahead; then
                echo "Found commits ready for quality gates"
            elif _has_uncommitted_changes; then
                echo ""
                echo -e "${YELLOW}Uncommitted changes detected${NC}"
                echo "Stage and commit your changes, then run /worker again"
                return 0
            else
                echo ""
                echo "Issue #$current_issue is claimed but no implementation yet."
                echo ""
                echo "Implement the solution, then run /worker again."
                echo "  View issue: gh issue view $current_issue --repo $OWNER/$REPO"
                return 0
            fi
        else
            # Step 3: Find and claim next issue
            echo ""
            echo -e "${BLUE}Step 3:${NC} Finding next issue..."
            local next_issue
            next_issue=$(_find_next_issue) || {
                echo "No agent-ready issues found"
                if [[ $issues_completed -eq 0 ]]; then
                    echo ""
                    echo "Waiting ${POLL_INTERVAL}s before checking again..."
                    echo "(Press Ctrl+C to stop)"
                    sleep "$POLL_INTERVAL"
                    continue
                else
                    echo ""
                    echo -e "${GREEN}Worker complete${NC} - $issues_completed issue(s) processed"
                    return 0
                fi
            }

            local issue_num
            issue_num=$(echo "$next_issue" | jq -r '.number')
            local issue_title
            issue_title=$(echo "$next_issue" | jq -r '.title')

            echo "Found: #$issue_num - $issue_title"

            if $DRY_RUN; then
                echo -e "${YELLOW}[DRY RUN]${NC} Would claim issue #$issue_num"
                ((issues_completed++))
                continue
            fi

            # Claim the issue atomically using existing skill
            echo ""
            echo -e "${BLUE}Step 4:${NC} Claiming issue..."
            local claim_output
            if ! claim_output=$("${SCRIPT_DIR}/claim-issue" "$issue_num" 2>&1); then
                echo -e "${RED}Failed to claim issue #$issue_num${NC}"
                echo "$claim_output"
                # Extract last line as error summary
                local error_summary
                error_summary=$(echo "$claim_output" | grep -i "error\|failed\|not found" | tail -1 | cut -c1-100)
                _log_history "CLAIM_FAILED" "$issue_num" "${error_summary:-Claim failed}"
                continue
            fi
            echo "$claim_output"

            local branch
            branch=$(_git branch --show-current 2>/dev/null || echo "")
            _set_current_issue "$issue_num" "$branch"
            current_issue="$issue_num"

            echo ""
            echo "Issue #$current_issue claimed. Implement the solution, then run /worker again."
            return 0
        fi

        # Step 5: Quality gates (only reached if we have commits)
        echo ""
        echo -e "${BLUE}Step 5:${NC} Running quality gates..."

        local retry_count
        retry_count=$(_get_retry_count)

        if ! _run_quality_gates "$current_issue"; then
            _increment_retry
            retry_count=$(_get_retry_count)

            if [[ "$retry_count" -ge "$MAX_RETRIES" ]]; then
                echo ""
                echo -e "${RED}Quality gates failed after $MAX_RETRIES attempts${NC}"
                _queue_decision "$current_issue" \
                    "Quality gates failing" \
                    "Tests or lint failing after $MAX_RETRIES fix attempts" \
                    '["Fix manually", "Skip quality gates", "Abandon issue"]'
                _log_history "BLOCKED" "$current_issue" "Quality gates failed after $MAX_RETRIES attempts"
                _clear_current_issue
                ((issues_completed++))
                continue
            fi

            echo ""
            echo "Attempt $retry_count of $MAX_RETRIES"
            echo "Fix the issues above and run /worker again"
            return 1
        fi

        # Step 6: Submit PR
        echo ""
        echo -e "${BLUE}Step 6:${NC} Submitting PR..."

        if $DRY_RUN; then
            echo -e "${YELLOW}[DRY RUN]${NC} Would submit PR for issue #$current_issue"
        else
            local submit_output
            if ! submit_output=$("${SCRIPT_DIR}/submit-pr" 2>&1); then
                echo -e "${RED}Failed to submit PR${NC}"
                echo "$submit_output"
                _log_history "FAILED" "$current_issue" "PR submission failed"
                # Escape quotes in output for JSON and truncate if too long
                local error_context
                error_context=$(echo "$submit_output" | tail -10 | sed 's/"/\\"/g' | tr '\n' ' ' | cut -c1-500)
                _queue_decision "$current_issue" \
                    "PR submission failed" \
                    "Error: ${error_context}" \
                    '["Retry manually", "Abandon issue"]'
                _clear_current_issue
                ((issues_completed++))
                continue
            fi
        fi

        echo ""
        echo -e "${GREEN}Issue #$current_issue completed successfully${NC}"
        _log_history "COMPLETED" "$current_issue" "PR submitted"
        _clear_current_issue
        ((issues_completed++))
    done

    echo ""
    echo "========================================"
    echo -e "${GREEN}Worker Complete${NC}"
    echo "========================================"
    echo "Issues processed: $issues_completed"
    echo ""
    echo "Review history: $HISTORY_FILE"
}

# ============================================================================
# MAIN
# ============================================================================

# Parse flags in correct order
_parse_project_flag "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"
REMAINING_ARGS=()
_parse_worker_flags "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"

# Initialize
_detect_mode
_get_repo_info

# Handle --reset flag
if $RESET_STATE; then
    # Set up paths without acquiring lock
    WORKER_DIR="${SCRIPT_DIR}/../worker"
    LOCK_FILE="${WORKER_DIR}/worker.lock"
    STATE_FILE="${WORKER_DIR}/current-issue"
    BRANCH_FILE="${WORKER_DIR}/current-branch"
    RETRY_FILE="${WORKER_DIR}/retry-count"
    DECISION_DIR="${WORKER_DIR}/decision-queue"
    _reset_worker_state
    exit 0
fi

_init_worker_state

# Run the loop
_worker_loop
