#!/usr/bin/env bash
# Skill: /telemetry-report
# Description: Generate usage report from telemetry invocation logs
# Usage: /telemetry-report [--period <n>d] [--json] [--verbose]

set -euo pipefail

# ============================================================================
# WORKSPACE/PROJECT MODE DETECTION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_PROJECT=""
MODE=""
REMAINING_ARGS=()

_parse_project_flag() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                if [[ -n "${2:-}" ]]; then
                    TARGET_PROJECT="$2"
                    shift 2
                else
                    echo "Error: --project requires a path argument"
                    exit 1
                fi
                ;;
            *)
                REMAINING_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

_load_workspace_config() {
    local config_file="${SCRIPT_DIR}/../workspace-config"
    if [[ -f "$config_file" ]]; then
        # shellcheck source=/dev/null
        source "$config_file"
        TARGET_PROJECT="${TARGET_PROJECT_PATH:-}"
        return 0
    fi
    return 1
}

_detect_mode() {
    if [[ -n "$TARGET_PROJECT" ]]; then
        MODE="explicit"
        return
    fi
    if _load_workspace_config; then
        MODE="workspace"
        return
    fi
    if git rev-parse --git-dir > /dev/null 2>&1; then
        TARGET_PROJECT="$(pwd)"
        MODE="in-project"
        return
    fi
    echo "Error: Not in a git repository and no workspace config found."
    exit 1
}

_parse_project_flag "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"
_detect_mode

# ============================================================================
# CONFIGURATION
# ============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Defaults
PERIOD_DAYS=30
OUTPUT_JSON=false
VERBOSE=false

# Telemetry paths
if [[ "$MODE" == "in-project" ]]; then
    TELEMETRY_DIR=".claude/telemetry"
else
    TELEMETRY_DIR="${TARGET_PROJECT}/.claude/telemetry"
fi
LOG_FILE="${TELEMETRY_DIR}/invocations.log"

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

while [[ $# -gt 0 ]]; do
    case "$1" in
        --period)
            if [[ -n "${2:-}" ]]; then
                # Parse period like "7d" or "30d"
                PERIOD_DAYS="${2%d}"
                shift 2
            else
                echo "Error: --period requires a value (e.g., 7d, 30d)"
                exit 1
            fi
            ;;
        --json)
            OUTPUT_JSON=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --help|-h)
            cat <<EOF
Usage: /telemetry-report [OPTIONS]

Generate usage report from telemetry invocation logs.

OPTIONS:
  --period <n>d     Filter to last N days (default: 30d)
  --json            Output as JSON
  --verbose, -v     Show session breakdown
  --project <path>  Target project path
  --help, -h        Show this help

EXAMPLES:
  /telemetry-report              # Default 30-day report
  /telemetry-report --period 7d  # Last 7 days
  /telemetry-report --json       # Machine-readable output

LOG FORMAT:
  {timestamp}|{session_id}|{skill}|{exit_code}|{duration_ms}

EOF
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# ============================================================================
# MAIN
# ============================================================================

# Check if log file exists
if [[ ! -f "$LOG_FILE" ]]; then
    if $OUTPUT_JSON; then
        echo '{"error": "No telemetry data found", "log_file": "'"$LOG_FILE"'"}'
    else
        echo -e "${YELLOW}No telemetry data found${NC}"
        echo "Log file: $LOG_FILE"
        echo ""
        echo "Telemetry logging not yet enabled. To enable:"
        echo "  1. Source lib/telemetry.sh in your skills"
        echo "  2. Call telemetry_start at skill entry"
    fi
    exit 0
fi

# Check if log file is empty
if [[ ! -s "$LOG_FILE" ]]; then
    if $OUTPUT_JSON; then
        echo '{"error": "No invocations recorded", "log_file": "'"$LOG_FILE"'"}'
    else
        echo -e "${YELLOW}No invocations recorded${NC}"
        echo "Log file exists but is empty."
    fi
    exit 0
fi

# Calculate cutoff timestamp for period filtering
CUTOFF_TIMESTAMP=$(date -d "-${PERIOD_DAYS} days" -Iseconds 2>/dev/null || date -v-${PERIOD_DAYS}d -Iseconds 2>/dev/null || echo "")

# Process log file with awk
# Log format: {timestamp}|{session_id}|{skill}|{exit_code}|{duration_ms}
REPORT=$(awk -F'|' -v cutoff="$CUTOFF_TIMESTAMP" -v output_json="$OUTPUT_JSON" -v verbose="$VERBOSE" '
BEGIN {
    total_invocations = 0
    total_success = 0
    total_failed = 0
    total_duration = 0
}

# Skip malformed lines
NF < 5 { next }

# Filter by period if cutoff is set
cutoff != "" && $1 < cutoff { next }

{
    timestamp = $1
    session = $2
    skill = $3
    exit_code = $4
    duration = $5

    # Track per-skill stats
    skills[skill]++
    if (exit_code == 0) {
        skill_success[skill]++
    } else {
        skill_failed[skill]++
    }
    skill_duration[skill] += duration

    # Track last invocation per skill
    if (timestamp > skill_last[skill]) {
        skill_last[skill] = timestamp
    }

    # Track sessions
    sessions[session] = 1

    # Totals
    total_invocations++
    if (exit_code == 0) total_success++
    else total_failed++
    total_duration += duration
}

END {
    num_sessions = length(sessions)
    avg_per_session = (num_sessions > 0) ? total_invocations / num_sessions : 0

    if (output_json == "true") {
        # JSON output
        printf "{\n"
        printf "  \"period_days\": %d,\n", '"$PERIOD_DAYS"'
        printf "  \"total_invocations\": %d,\n", total_invocations
        printf "  \"total_success\": %d,\n", total_success
        printf "  \"total_failed\": %d,\n", total_failed
        printf "  \"total_duration_ms\": %d,\n", total_duration
        printf "  \"sessions\": %d,\n", num_sessions
        printf "  \"avg_skills_per_session\": %.1f,\n", avg_per_session
        printf "  \"skills\": {\n"

        first = 1
        for (skill in skills) {
            if (!first) printf ",\n"
            first = 0
            success = skill_success[skill] + 0
            failed = skill_failed[skill] + 0
            printf "    \"%s\": {\"count\": %d, \"success\": %d, \"failed\": %d, \"duration_ms\": %d, \"last\": \"%s\"}",
                skill, skills[skill], success, failed, skill_duration[skill], skill_last[skill]
        }
        printf "\n  }\n"
        printf "}\n"
    } else {
        # Human-readable output
        printf "========================================\n"
        printf "Skill Usage Report\n"
        printf "========================================\n"
        printf "Period: Last %d days (%d invocations)\n\n", '"$PERIOD_DAYS"', total_invocations

        # Sort skills by count (simple bubble sort in awk)
        n = 0
        for (skill in skills) {
            sorted_skills[++n] = skill
        }

        for (i = 1; i <= n; i++) {
            for (j = i + 1; j <= n; j++) {
                if (skills[sorted_skills[i]] < skills[sorted_skills[j]]) {
                    tmp = sorted_skills[i]
                    sorted_skills[i] = sorted_skills[j]
                    sorted_skills[j] = tmp
                }
            }
        }

        printf "%-4s  %-20s  %5s  %7s  %6s  %s\n", "Rank", "Skill", "Count", "Success", "Failed", "Last Used"
        printf "%-4s  %-20s  %5s  %7s  %6s  %s\n", "----", "-----", "-----", "-------", "------", "---------"

        for (i = 1; i <= n; i++) {
            skill = sorted_skills[i]
            success = skill_success[skill] + 0
            failed = skill_failed[skill] + 0

            # Format last used (simplified - just show timestamp)
            last = skill_last[skill]
            if (last == "") last = "never"
            else last = substr(last, 1, 10)  # Just date portion

            printf "%-4d  %-20s  %5d  %7d  %6d  %s\n", i, skill, skills[skill], success, failed, last
        }

        printf "\n"
        printf "Sessions: %d unique\n", num_sessions
        printf "Avg skills/session: %.1f\n", avg_per_session

        if (total_failed > 0) {
            printf "\n"
            printf "Failed invocations: %d (%.1f%%)\n", total_failed, (total_failed * 100.0 / total_invocations)
        }
    }
}
' "$LOG_FILE")

echo "$REPORT"
