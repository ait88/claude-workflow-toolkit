#!/usr/bin/env bash
# Skill: /check-workflow
# Description: Validate workflow state using optimized GraphQL queries
# Usage: /check-workflow [--project <path>]

set -euo pipefail

# ============================================================================
# WORKSPACE/PROJECT MODE DETECTION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_PROJECT=""
TARGET_REPO_OWNER=""
TARGET_REPO_NAME=""
MODE=""
REMAINING_ARGS=()

_parse_project_flag() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                if [[ -n "${2:-}" ]]; then
                    TARGET_PROJECT="$2"
                    shift 2
                else
                    echo "Error: --project requires a path argument"
                    exit 1
                fi
                ;;
            --repo|-r)
                if [[ -n "${2:-}" ]]; then
                    TARGET_REPO_OWNER="${2%%/*}"
                    TARGET_REPO_NAME="${2##*/}"
                    shift 2
                else
                    echo "Error: --repo requires owner/name argument"
                    exit 1
                fi
                ;;
            *)
                REMAINING_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

_load_workspace_config() {
    local config_file="${SCRIPT_DIR}/../workspace-config"
    if [[ -f "$config_file" ]]; then
        # shellcheck source=/dev/null
        source "$config_file"
        TARGET_PROJECT="${TARGET_PROJECT_PATH:-}"
        TARGET_REPO_OWNER="${TARGET_REPO_OWNER:-}"
        TARGET_REPO_NAME="${TARGET_REPO_NAME:-}"
        return 0
    fi
    return 1
}

_detect_mode() {
    if [[ -n "$TARGET_PROJECT" ]] || [[ -n "$TARGET_REPO_OWNER" ]]; then
        MODE="explicit"
        return
    fi
    if _load_workspace_config; then
        MODE="workspace"
        return
    fi
    if git rev-parse --git-dir > /dev/null 2>&1; then
        TARGET_PROJECT="$(pwd)"
        MODE="in-project"
        return
    fi
    echo "Error: Not in a git repository and no workspace config found."
    echo ""
    echo "Options:"
    echo "  1. Run from within the target project directory"
    echo "  2. Use --project <path> flag"
    echo "  3. Create .claude/workspace-config with TARGET_PROJECT_PATH"
    exit 1
}

_get_repo_info() {
    if [[ -n "$TARGET_REPO_OWNER" ]] && [[ -n "$TARGET_REPO_NAME" ]]; then
        OWNER="$TARGET_REPO_OWNER"
        REPO="$TARGET_REPO_NAME"
    else
        local repo_info
        if [[ -n "$TARGET_PROJECT" ]] && [[ "$MODE" != "in-project" ]]; then
            repo_info=$(cd "$TARGET_PROJECT" && gh repo view --json owner,name)
        else
            repo_info=$(gh repo view --json owner,name)
        fi
        OWNER=$(echo "$repo_info" | jq -r '.owner.login')
        REPO=$(echo "$repo_info" | jq -r '.name')
    fi
}

_git() {
    if [[ "$MODE" == "in-project" ]]; then
        git "$@"
    else
        git -C "$TARGET_PROJECT" "$@"
    fi
}

_parse_project_flag "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"
_detect_mode
_get_repo_info

# ============================================================================
# END MODE DETECTION
# ============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Get current branch
BRANCH=$(_git branch --show-current)

if [[ -z "$BRANCH" ]]; then
    echo -e "${RED}Error: Not on a branch${NC}"
    exit 1
fi

# Extract issue number from branch name
ISSUE=$(echo "$BRANCH" | grep -oE '^[0-9]+' || echo "")

if [[ -z "$ISSUE" ]]; then
    # Not on an issue branch - provide useful guidance instead of just skipping
    echo -e "${BLUE}Current branch:${NC} ${BRANCH}"
    echo ""
    echo "========================================"
    echo "Workspace Status"
    echo "========================================"
    echo ""

    # Find toolkit source for validation
    TOOLKIT_SOURCE="${TOOLKIT_SOURCE:-}"
    if [[ -z "$TOOLKIT_SOURCE" ]]; then
        if [[ -d "$HOME/claude-workflow-toolkit" ]]; then
            TOOLKIT_SOURCE="$HOME/claude-workflow-toolkit"
        elif [[ -d "${SCRIPT_DIR}/../../templates" ]]; then
            TOOLKIT_SOURCE="$(realpath "${SCRIPT_DIR}/../..")"
        fi
    fi

    # Quick skill staleness check
    if [[ -n "$TOOLKIT_SOURCE" ]] && [[ -d "$TOOLKIT_SOURCE/templates/skills" ]]; then
        OUTDATED=0
        MISSING=0
        SKILLS_DIR="${SCRIPT_DIR}"

        for template in "$TOOLKIT_SOURCE/templates/skills/"*.sh.template; do
            [[ -f "$template" ]] || continue
            skill_name=$(basename "$template" .sh.template)
            installed_file="$SKILLS_DIR/$skill_name"

            if [[ ! -f "$installed_file" ]]; then
                ((++MISSING))
            elif [[ "$template" -nt "$installed_file" ]]; then
                ((++OUTDATED))
            fi
        done

        if [[ $OUTDATED -eq 0 ]] && [[ $MISSING -eq 0 ]]; then
            echo -e "${GREEN}Skills:${NC} All up to date"
        else
            [[ $OUTDATED -gt 0 ]] && echo -e "${YELLOW}Skills:${NC} $OUTDATED outdated"
            [[ $MISSING -gt 0 ]] && echo -e "${YELLOW}Skills:${NC} $MISSING missing"
            echo -e "  Run: ${BLUE}/sync-skills${NC}"
        fi
    else
        echo -e "${YELLOW}Skills:${NC} Could not locate toolkit source for validation"
    fi

    # Check for PRs needing review
    PENDING_REVIEWS=$(gh pr list --repo "$OWNER/$REPO" --state open --json number,reviews \
        --jq '[.[] | select(.reviews | length > 0) | select(.reviews | map(select(.state == "CHANGES_REQUESTED")) | length > 0)] | length' 2>/dev/null || echo "0")

    if [[ "$PENDING_REVIEWS" -gt 0 ]]; then
        echo -e "${YELLOW}PRs needing attention:${NC} $PENDING_REVIEWS"
        echo -e "  Run: ${BLUE}/check-reviews${NC}"
    else
        echo -e "${GREEN}PRs needing attention:${NC} None"
    fi

    # Check for agent-ready issues
    AGENT_READY=$(gh issue list --repo "$OWNER/$REPO" --label "agent-ready" --state open --json number --jq 'length' 2>/dev/null || echo "0")
    echo -e "${BLUE}Issues ready for work:${NC} $AGENT_READY"

    echo ""
    echo "========================================"
    echo "Next Steps"
    echo "========================================"
    echo ""
    echo -e "1. ${BLUE}/check-reviews${NC}     - Check for PRs needing attention"
    if [[ $OUTDATED -gt 0 ]] || [[ $MISSING -gt 0 ]]; then
        echo -e "2. ${BLUE}/sync-skills${NC}      - Update outdated skills"
        echo -e "3. ${BLUE}/claim-issue <n>${NC}  - Start work on an issue"
    else
        echo -e "2. ${BLUE}/claim-issue <n>${NC}  - Start work on an issue"
    fi
    echo ""
    echo "Find work: gh issue list --repo $OWNER/$REPO --label agent-ready"
    exit 0
fi

echo "Validating workflow for issue #${ISSUE} on branch ${BRANCH}..."
echo ""

# Single GraphQL query to fetch all needed data
QUERY=$(cat <<EOF
query {
  repository(owner: "$OWNER", name: "$REPO") {
    issue(number: $ISSUE) {
      number
      title
      state
      labels(first: 20) {
        nodes {
          name
        }
      }
    }
    pullRequests(headRefName: "$BRANCH", first: 1, states: OPEN) {
      nodes {
        number
        state
      }
    }
  }
}
EOF
)

RESULT=$(gh api graphql -f query="$QUERY")

# Parse results
ISSUE_STATE=$(echo "$RESULT" | jq -r '.data.repository.issue.state')
ISSUE_TITLE=$(echo "$RESULT" | jq -r '.data.repository.issue.title')
LABELS=$(echo "$RESULT" | jq -r '.data.repository.issue.labels.nodes[].name' | tr '\n' ' ')
HAS_PR=$(echo "$RESULT" | jq -r '.data.repository.pullRequests.nodes | length > 0')
PR_NUMBER=$(echo "$RESULT" | jq -r '.data.repository.pullRequests.nodes[0].number // ""')

echo -e "${BLUE}Issue:${NC} #${ISSUE} - ${ISSUE_TITLE}"
echo -e "${BLUE}State:${NC} ${ISSUE_STATE}"
echo -e "${BLUE}Labels:${NC} ${LABELS:-"(none)"}"
if [[ "$HAS_PR" == "true" ]]; then
    echo -e "${BLUE}Pull Request:${NC} #${PR_NUMBER}"
fi
echo ""

# Validation
echo "========================================"
echo "Workflow Validation"
echo "========================================"
echo ""

ERRORS=0
WARNINGS=0

# Check issue state
if [[ "$ISSUE_STATE" == "CLOSED" ]]; then
    echo -e "${RED}CRITICAL:${NC} Issue is closed but you're on its branch"
    ((ERRORS++))
fi

# Check labels based on PR status
if [[ "$HAS_PR" == "true" ]]; then
    if echo "$LABELS" | grep -q "needs-review"; then
        echo -e "${GREEN}OK:${NC} Issue has 'needs-review' label (PR created)"
    else
        echo -e "${RED}ERROR:${NC} PR exists but issue doesn't have 'needs-review' label"
        echo "  Fix: gh issue edit $ISSUE --repo $OWNER/$REPO --add-label \"needs-review\""
        ((ERRORS++))
    fi
    if echo "$LABELS" | grep -q "in-progress"; then
        echo -e "${YELLOW}WARNING:${NC} Issue has 'in-progress' but PR already created"
        echo "  Fix: gh issue edit $ISSUE --repo $OWNER/$REPO --remove-label \"in-progress\""
        ((WARNINGS++))
    fi
else
    if echo "$LABELS" | grep -q "in-progress"; then
        echo -e "${GREEN}OK:${NC} Issue has 'in-progress' label (actively working)"
    else
        echo -e "${RED}ERROR:${NC} Working on issue but doesn't have 'in-progress' label"
        echo "  Fix: gh issue edit $ISSUE --repo $OWNER/$REPO --add-label \"in-progress\""
        ((ERRORS++))
    fi
    if echo "$LABELS" | grep -q "agent-ready"; then
        echo -e "${YELLOW}WARNING:${NC} Issue still has 'agent-ready' label"
        echo "  Fix: gh issue edit $ISSUE --repo $OWNER/$REPO --remove-label \"agent-ready\""
        ((WARNINGS++))
    fi
fi

# Check for phase labels
if ! echo "$LABELS" | grep -qE '{{PHASE_PREFIX}}[0-9]+'; then
    echo -e "${YELLOW}WARNING:${NC} Issue doesn't have a phase label"
    ((WARNINGS++))
fi

echo ""
echo "========================================"

if [[ $ERRORS -eq 0 && $WARNINGS -eq 0 ]]; then
    echo -e "${GREEN}All checks passed!${NC}"
elif [[ $ERRORS -eq 0 ]]; then
    echo -e "${YELLOW}$WARNINGS warning(s) found${NC}"
    exit 0
else
    echo -e "${RED}$ERRORS error(s), $WARNINGS warning(s) found${NC}"
    exit 1
fi
