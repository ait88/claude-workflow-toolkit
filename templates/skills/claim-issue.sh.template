#!/usr/bin/env bash
# Skill: /claim-issue
# Description: Atomically claim a GitHub issue and create feature branch
# Usage: /claim-issue [--project <path>] <issue-number>

set -euo pipefail

# ============================================================================
# WORKSPACE/PROJECT MODE DETECTION
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_PROJECT=""
TARGET_REPO_OWNER=""
TARGET_REPO_NAME=""
MODE=""
REMAINING_ARGS=()

_parse_project_flag() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                if [[ -n "${2:-}" ]]; then
                    TARGET_PROJECT="$2"
                    shift 2
                else
                    echo "Error: --project requires a path argument"
                    exit 1
                fi
                ;;
            --repo|-r)
                if [[ -n "${2:-}" ]]; then
                    TARGET_REPO_OWNER="${2%%/*}"
                    TARGET_REPO_NAME="${2##*/}"
                    shift 2
                else
                    echo "Error: --repo requires owner/name argument"
                    exit 1
                fi
                ;;
            *)
                REMAINING_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

_load_workspace_config() {
    local config_file="${SCRIPT_DIR}/../workspace-config"
    if [[ -f "$config_file" ]]; then
        # shellcheck source=/dev/null
        source "$config_file"
        TARGET_PROJECT="${TARGET_PROJECT_PATH:-}"
        TARGET_REPO_OWNER="${TARGET_REPO_OWNER:-}"
        TARGET_REPO_NAME="${TARGET_REPO_NAME:-}"
        return 0
    fi
    return 1
}

_detect_mode() {
    if [[ -n "$TARGET_PROJECT" ]] || [[ -n "$TARGET_REPO_OWNER" ]]; then
        MODE="explicit"
        return
    fi
    if _load_workspace_config; then
        MODE="workspace"
        return
    fi
    if git rev-parse --git-dir > /dev/null 2>&1; then
        TARGET_PROJECT="$(pwd)"
        MODE="in-project"
        return
    fi
    echo "Error: Not in a git repository and no workspace config found."
    echo ""
    echo "Options:"
    echo "  1. Run from within the target project directory"
    echo "  2. Use --project <path> flag"
    echo "  3. Create .claude/workspace-config with TARGET_PROJECT_PATH"
    exit 1
}

_get_repo_info() {
    if [[ -n "$TARGET_REPO_OWNER" ]] && [[ -n "$TARGET_REPO_NAME" ]]; then
        OWNER="$TARGET_REPO_OWNER"
        REPO="$TARGET_REPO_NAME"
    else
        local repo_info
        if [[ -n "$TARGET_PROJECT" ]] && [[ "$MODE" != "in-project" ]]; then
            repo_info=$(cd "$TARGET_PROJECT" && gh repo view --json owner,name)
        else
            repo_info=$(gh repo view --json owner,name)
        fi
        OWNER=$(echo "$repo_info" | jq -r '.owner.login')
        REPO=$(echo "$repo_info" | jq -r '.name')
    fi
}

_git() {
    if [[ "$MODE" == "in-project" ]]; then
        git "$@"
    else
        git -C "$TARGET_PROJECT" "$@"
    fi
}

_parse_project_flag "$@"
set -- "${REMAINING_ARGS[@]+"${REMAINING_ARGS[@]}"}"
_detect_mode
_get_repo_info

# ============================================================================
# END MODE DETECTION
# ============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# ============================================================================
# LABEL MANAGEMENT
# ============================================================================

# Ensure a label exists, creating it if necessary
# Usage: _ensure_label "label-name" "description" "color"
_ensure_label() {
    local label="$1"
    local description="${2:-}"
    local color="${3:-}"

    # Check if label exists
    if ! gh label list --repo "$OWNER/$REPO" --json name --jq '.[].name' 2>/dev/null | grep -q "^${label}$"; then
        echo "Creating missing label: ${label}"
        local args=(--repo "$OWNER/$REPO" "$label")
        [[ -n "$description" ]] && args+=(--description "$description")
        [[ -n "$color" ]] && args+=(--color "$color")
        gh label create "${args[@]}" 2>/dev/null || true
    fi
}

# Ensure all workflow labels exist
_ensure_workflow_labels() {
    _ensure_label "agent-ready" "Issue is ready for agent to work on" "aaaaaa"
    _ensure_label "in-progress" "Issue is being worked on" "fbca04"
    _ensure_label "needs-review" "PR ready for review" "0e8a16"
    _ensure_label "blocked" "Blocked by external factor" "b60205"
}

# Validate arguments
if [[ $# -lt 1 ]]; then
    echo -e "${RED}Usage: /claim-issue [--project <path>] <issue-number>${NC}"
    exit 1
fi

ISSUE="$1"

# Validate issue number is numeric
if ! [[ "$ISSUE" =~ ^[0-9]+$ ]]; then
    echo -e "${RED}Error: Issue number must be numeric${NC}"
    exit 1
fi

echo "Claiming issue #${ISSUE}..."

# Fetch issue details (using explicit repo)
ISSUE_DATA=$(gh issue view "$ISSUE" --repo "$OWNER/$REPO" --json title,state,labels 2>/dev/null) || {
    echo -e "${RED}Error: Could not fetch issue #${ISSUE} from $OWNER/$REPO${NC}"
    exit 1
}

STATE=$(echo "$ISSUE_DATA" | jq -r '.state')
TITLE=$(echo "$ISSUE_DATA" | jq -r '.title')
LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels[].name' | tr '\n' ' ')

# Validate issue is open
if [[ "$STATE" != "OPEN" ]]; then
    echo -e "${RED}Error: Issue #${ISSUE} is not open (state: ${STATE})${NC}"
    exit 1
fi

# Check if already claimed
if echo "$LABELS" | grep -q "in-progress"; then
    echo -e "${YELLOW}Warning: Issue #${ISSUE} already has 'in-progress' label${NC}"
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 0
    fi
fi

# Generate branch name from title
BRANCH_SLUG=$(echo "$TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//' | cut -c1-50)
BRANCH="${ISSUE}-${BRANCH_SLUG}"

echo "Issue: #${ISSUE} - ${TITLE}"
echo "Branch: ${BRANCH}"
echo ""

# Ensure workflow labels exist
_ensure_workflow_labels

# Update labels atomically (using explicit repo)
# First add in-progress, then remove agent-ready to avoid orphaned state
echo "Updating labels..."
if ! gh issue edit "$ISSUE" --repo "$OWNER/$REPO" --add-label "in-progress" 2>/dev/null; then
    echo -e "${RED}Error: Failed to add 'in-progress' label${NC}"
    exit 1
fi

# Now safe to remove agent-ready (issue is already marked in-progress)
gh issue edit "$ISSUE" --repo "$OWNER/$REPO" --remove-label "agent-ready" 2>/dev/null || true

# Helper function for SSH/HTTPS fallback
git_with_fallback() {
    local cmd="$1"
    shift
    if ! _git "$cmd" "$@" 2>/dev/null; then
        echo "SSH failed, trying HTTPS via gh auth..."
        gh auth setup-git 2>/dev/null || true
        _git "$cmd" "$@"
    fi
}

# Sync with latest main before creating branch
echo "Syncing with latest {{DEFAULT_BRANCH}}..."
git_with_fallback fetch origin {{DEFAULT_BRANCH}} || git_with_fallback fetch origin main || true
_git checkout {{DEFAULT_BRANCH}} 2>/dev/null || _git checkout main
git_with_fallback pull origin {{DEFAULT_BRANCH}} || git_with_fallback pull origin main || true
echo ""
echo "Creating branch..."

if _git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
    echo -e "${YELLOW}Branch ${BRANCH} already exists, checking out...${NC}"
    _git checkout "$BRANCH"
else
    _git checkout -b "$BRANCH"
fi

echo ""
echo -e "${GREEN}Issue #${ISSUE} claimed successfully${NC}"
echo ""
echo "Next steps:"
echo "  1. Implement the changes"
echo "  2. Run tests: {{TEST_COMMAND}}"
echo "  3. Commit: git commit -m \"feat(scope): description (#${ISSUE})\""
echo "  4. Submit: /submit-pr"
